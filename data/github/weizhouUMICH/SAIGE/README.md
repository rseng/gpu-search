# https://github.com/weizhouUMICH/SAIGE

```console
thirdParty/bgen/3rd_party/boost_1_55_0/libs/math/test/test_next.cpp:#if !defined(_CRAYC) && !defined(__CUDACC__) && (!defined(__GNUC__) || (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ > 3)))
thirdParty/bgen/3rd_party/boost_1_55_0/libs/math/quaternion/TQE.pdf:0@sKnlmW$UZNMmJnOjab.Oh+C78X:$>;Zr!=&Q-Obl^p1gpU?5K:o/WX0NcTgsu/_
thirdParty/bgen/3rd_party/boost_1_55_0/libs/wave/samples/cpp_tokens/slex/lexer.hpp:    out << "\nccl_node m_match = ";
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:cG5ucGxubXFvb2xqbG1rbGpua2ppZ2xta2xsbG1sbWxpbWpraWlpaWppbW5qa2pr
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:bm50eW9vbW1rbW9tbWlqbWtobGpubm1ub2traWlqZmlqa2xnZ2VhY2dmZmlqaWdn
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:cnR0cnJycXNycXFwcHFvcXFubWxubG1sa2tqbHFxcG9vbnJybm5vcm1wbGpuamxs
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:ZmdmZWRlY2ZlZWVnZWVnbGpta21wa21raGdoa2xpa25xbWxva2tsbGpucG9rb29v
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:ZmhpamtpamloaWdram1paW1qbXBqaWpubGtramlvcXJybGxsbGpub29qaGlqbXFu
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:ZmZqaGlpZmZmZWppa2prbGxraWlmZmdmZGVmZmttaGpua2htbWpoZWVkaGdsi7XN
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:aWZoaWtoaWtramtpaGpua2ppZWVnZmtrbG9sam1sa2tsbGttbGxubW1tbW9vbm5w
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:dXRwc3N0c3FwcXBxdHN2c3JzdHFxcHVycnNyb3Bxc3Nyc3NwcG9saGpubGxubm5v
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:bm1rbGptcW9raGpucnFua2pubGtub2dmamxqbG9wb21vb2xrbm5pam5xcG1samtq
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:cnF1cm5ub3N0c3RxdGpubXFwbWtra2tubHJxcG9wb2ttbmlrb3BycG1wbGxtb3Bw
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:cG9wbXBycm9zb2xtbnBubGpubWtra2pnZWhoaGpscGtqa2xra2tub3Bua21sb29r
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:WVtgYWRjX15dYWVlYmBiYGdlYl9hZGdmZWdlZGpucXFwcHJzdXFwcnZ4d3V1cG1s
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:Z2hxc3FwbWRkYWBgYl9eYGRmYVtbYGloZ2lnZ19fa3FqaWhpaWdqaWRlaGpub3Bt
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:YGJjZ2hoaGpucG1saWluc3VxaWhra2lqbGloaGZpbXBydXZycG9wdHNwbnJvbnJx
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:cnV0cHR1cnRzdHR0dXNzc3BxbGpubmxsbWpvbW1ubm1tbmxqb3NubGtramlqbGxu
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:Z2loZWVgZWltbGtqbGpucmxtcHBycXJ1dXl5dnh8fn+AhoeJjIyLi4iGiYiMi46L
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:bm1vbm9vbWhoZmdna2lpaGRfYF5eYl5gaXBuamZeW1tdZGhpamdmZmhnZGpubm1x
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:Z2NlYWNpamtpY2VlY2Zoa2tsbGpubG1ubm5sa3Bzd3d5fHyAgIWEgn6AgoqNh4OE
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:XWBgX15iYWFfXmRlamZiZGRfYWNgYmdpbGlnaWdoZmlubGpub25wbG9ydnl3d3h6
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:bWxtbm5xcXRzcG10dG9vcW1sbGpubGxtbnFwbWtraWtoaGhkYmZmZ2ZlZmxwcnJw
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:Yl5fXl9eYGRjZmlmZmdnZ2dlYmRlaGpubm9taWxucG9ub25sb3FwcXJycnR3e3x4
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:TE1NUFZaVFRXWVlXVExMT1FWTkpLTlFQUU9NUVRVWFhaXF1iZGdjaGxvcGpucG1x
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:a25ua2xsamloamhubGpucXNyd31/hIePkZKSmJyenqGiop+fnJmXmpuem5mWmJua
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:Oj06PDs5Ojs7Ojo5OTs+QURHRkRDQ0NIRURHS05SU1dcZGpudXV3dm5pY1lTU01K
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:YF9eXWJjXEtBOzo4Ojk8QD88QTw3NTk9OT88P0M8Oz1ESEZAOz1ARkhGPUBAQkFE
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:Nzg1OTc6PDg5Nzg6Oz5CRERFQUZGPUBBSEtESklNSkhLSU9TTlFVVFVUUlNQWVRX
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:V1ZTV1NUV1VdWlZWVlJSUlZcVVBGPUE+Nzc1NTc3Nzk4PEJGRlFRTFNTUFBMUE9P
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:U1NSUlJQUFNRUVRRUVJTVFRWVVlcXmFlaGpuc3V9gH6Ch4qNjpKTlpSYlpibnJyY
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:ZWRmaGpubG5ucHBydXV3dXJycHR0dHFzc3Nyd3N6fX14d3l/gH+AhIOBgoiHhYaF
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:YmBhYWJgZGpuam5ydnt9fnZzcW5saWZkYmJcWlldWlZVVFZTU1RVVlVaV1ZYV1Vb
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:Ojo7OTg4ODk5OTo6Ojk0Njk6PEhPTE5SVV1iY1xPS01WXlNGPURWYVVCPT5HRz43
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:Ojg5PDtBQTo/OTs8Pj8+ODw+QUM5PT48PT9CPj5BREM+Q0VLRkZQRklGPUBEaLPH
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:RUQ+QD1GSUlCP0FDP0VBQD5DP0NCQENGPUE7PDk6Ozg6Njg4NTU8PD1DOzk3PD46
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:aFNBQEeEm29CQUVGREZGPUBAQkFARUVBPUJBQUFCPUBBPT5BQkJAQDw8PT5APkBD
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:5Obo6enq6llUY2NVSU9SRkpJRklRTEtMSExER0ZHRkhKSENGPUNDQkJBPz4+PDk8
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:PkNCQ0RBQUREQ0hBPkA+PkNIR0I7PDs+PDpAQT4/PT8+PUBGPUNCPj8/OkA+RD48
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:QT9APj1BPUE7PD0+Pz1AQUBBQEM9P0RDRENFQUBAQ0JDQUJGPUFBQkFBPz07Oz0/
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:RUJIRUVFRkRAQklMREJHRkM+RUVER0c/P0hERU1NQ0FBRkhFRkhLREZDRENGPUdJ
thirdParty/bgen/3rd_party/boost_1_55_0/libs/algorithm/test/search_test_data/0001.corpus:X2djZnRrZW5rcmtqdH1zcGVqbmhraWV0bWpobWtycW9zaHBrb25oaGpuc2ZjZV9k
thirdParty/bgen/3rd_party/boost_1_55_0/libs/asio/doc/reference.qbk:POSIX allows signals to be blocked using functions such as `sigprocmask()` and `pthread_sigmask()`. For signals to be delivered, programs must ensure that any signals registered using signal\_set objects are unblocked in at least one thread. 
thirdParty/bgen/3rd_party/boost_1_55_0/libs/asio/doc/reference.qbk:POSIX allows signals to be blocked using functions such as `sigprocmask()` and `pthread_sigmask()`. For signals to be delivered, programs must ensure that any signals registered using signal\_set objects are unblocked in at least one thread. 
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/test_external/thrust/Makefile:CUDA_ROOT = /usr/local/cuda
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/test_external/thrust/Makefile:NVCC = $(CUDA_ROOT)/bin/nvcc
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/test_external/thrust/Makefile:INCLUDES += -I$(BOOST_ROOT) -I$(THRUST_ROOT) -I$(CUDA_ROOT)/include -I../../../../..
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/test_external/thrust/Makefile:LDLIBS = -lcudart
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/test_external/thrust/Makefile:LDFLAGS = -L$(CUDA_ROOT)/lib64
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/test_external/vexcl/Jamfile.v2:CUDA_INCLUDE = /usr/local/cuda/include ;
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/test_external/vexcl/Jamfile.v2:      <include>$(CUDA_INCLUDE)
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/test_external/vexcl/Jamfile.v2:lib OpenCL : : <name>OpenCL <link>shared ;
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/test_external/vexcl/Jamfile.v2:    [ run lorenz.cpp OpenCL ]
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/test_external/vexcl/lorenz.cpp:    vex::Context ctx( vex::Filter::Type(CL_DEVICE_TYPE_GPU) );
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_vexcl_opencl.qbk:[section Using OpenCL via VexCL]
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_vexcl_opencl.qbk:In the previous section the usage of odeint in combination with __thrust was shown. In this section we show how one can use OpenCL with odeint. The point of odeint is not to implement its own low-level data structures and algorithms, but to use high level libraries doing this task. Here, we will use the __vexcl framework to use OpenCL. __vexcl is a nice library for general computations and it uses heavily expression templates. With the help of __vexcl it is possible to write very compact and expressive application.
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_vexcl_opencl.qbk:It's very easy, isn't it? These three little lines do all the computations for you. There is no need to write your own OpenCL kernels. __vexcl does everything for you. Next we have to write the main application. We initialize the vector of parameters (R) and the initial state. Since __vexcl supports odeint we can already use the `vector_space_algebra` in combination with the `default_operations` for the stepper and we are done:
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/getting_started.qbk:* __thrust, making odeint naturally running on CUDA devices
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/getting_started.qbk:* __vexcl for OpenCL
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/html/standalone_HTML.manifest:boost_numeric_odeint/tutorial/using_cuda__or_openmp__tbb_______via_thrust.html
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/html/standalone_HTML.manifest:boost_numeric_odeint/tutorial/using_opencl_via_vexcl.html
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/examples_table.qbk:  [The Thrust phase oscillator ensemble example shows how globally coupled oscillators can be analyzed with Thrust and CUDA, employing the power of modern graphic devices.]]
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/examples_table.qbk:  [This example shows how the VexCL - a framework for OpenCL computation - can be used with odeint.]]
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:[section Using CUDA (or OpenMP, TBB, ...) via Thrust]
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:Modern graphic cards (graphic processing units - GPUs) can be used to speed up
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:parallel. odeint can utilize the power of GPUs by means of CUDA and __thrust,
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:which is a STL-like interface for the native CUDA API.
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:between CUDA, OpenMP and TBB parallelizations by a simple compiler
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:parallelization into odeint. The examples discussed below are focused on GPU parallelization, though. ]
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:To use odeint with CUDA a few points have to be taken into account. First of all, the problem has to be well chosen. It makes absolutely no sense to try to parallelize the code for a three dimensional system, it is simply too small and not worth the effort. One single function call (kernel execution) on the GPU is slow but you can do the operation on a huge set of data with only one call. We have experienced that the vector size over which is parallelized should be of the order of ['10[super 6]] to make full use of the GPU. Secondly, you have to use __thrust's algorithms and functors when implementing the rhs the ODE. This might be tricky since it involves some kind of functional programming knowledge.
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:Typical applications for CUDA and odeint are large systems, like lattices or discretizations of PDE, and parameter studies. We introduce now three examples which show how the power of GPUs can be used in combination with odeint.
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:[important The full power of CUDA is only available for really large systems where the number of coupled ordinary differential equations is of order ['N=10[super 6]] or larger. For smaller systems the CPU is usually much faster. You can also integrate an ensemble of different uncoupled ODEs in parallel as shown in the last example.]
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:__thrust and CUDA are perfectly suited for such kinds of problems where one needs a large number of particles (oscillators). We start by defining the state type which is a `thrust::device_vector`. The content of this vector lives on the GPU. If you are not familiar with this we recommend reading the ['Getting started] section on the __thrust website.
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:Thrust follows a functional programming approach. If you want to perform a calculation on the GPU you usually have to call a global function like `thrust::for_each`, `thrust::reduce`, ... with an appropriate local functor which performs the basic operation. An example is
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:Inside this class two member structures `sin_functor` and `cos_functor` are defined. They compute the sine and the cosine of a value and they are used within a transform iterator to calculate the sum of ['sin(__phi[subl k])] and ['cos(__phi[subl k])]. The classifiers `__host__` and `__device__` are CUDA specific and define a function or operator which can be executed on the GPU as well as on the CPU. The line 
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:performs the calculation of this sine-sum on the GPU (or on the CPU, depending on your thrust configuration).
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:Now, we are ready to put everything together. All we have to do for making odeint ready for using the GPU is to parametrize the stepper with the appropriate thrust algebra/operations:
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial_thrust_cuda.qbk:Another important use case for __thrust and CUDA are parameter studies of relatively small systems. Consider for example the three-dimensional Lorenz system from the chaotic systems example in the previous section which has three parameters. If you want to study the behavior of this system for different parameters you usually have to integrate the system for many parameter values. Using thrust and odeint you can do this integration in parallel, hence you integrate a whole ensemble of Lorenz systems where each individual realization has a different parameter value. 
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/concepts/state_algebra_operations.qbk:  [[`thrust::device_vector`, `thrust::host_vector`] [`thrust_algebra`] [`thrust_operations`] [For running odeint on CUDA devices by using __thrust]]
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial.qbk:[include tutorial_thrust_cuda.qbk]
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/doc/tutorial.qbk:[include tutorial_vexcl_opencl.qbk]
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/relaxation.cu:// change to float if your GPU does not support doubles
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/phase_oscillator_ensemble.cu: * The example how the phase_oscillator ensemble can be implemented using CUDA and thrust
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/phase_oscillator_chain.cu: * This example shows how to use odeint on CUDA devices with thrust.
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/phase_oscillator_chain.cu: * Note that we require at least Version 3.2 of the nVidia CUDA SDK
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/phase_oscillator_chain.cu: * and the thrust library should be installed in the CUDA include
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/Makefile:# CUDA_ROOT = /home/karsten/boost/cuda4.1/cuda/
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/Makefile:CUDA_ROOT = /usr/local/cuda
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/Makefile:NVCC = $(CUDA_ROOT)/bin/nvcc
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/Makefile:INCLUDES += -I$(BOOST_ROOT) -I$(THRUST_ROOT) -I$(CUDA_ROOT)/include -I../../../../..
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/Makefile:LDLIBS = -lcudart -lgomp
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/Makefile:LDFLAGS = -L$(CUDA_ROOT)/lib64
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/lorenz_parameters.cu: * The example how the phase_oscillator ensemble can be implemented using CUDA and thrust
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/lorenz_parameters.cu:    cudaDriverGetVersion( &driver_version );
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/thrust/lorenz_parameters.cu:    cudaRuntimeGetVersion ( &runtime_version );
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/vexcl/Jamfile.v2:CUDA_INCLUDE = /usr/local/cuda/include ;
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/vexcl/Jamfile.v2:lib opencl : : <name>OpenCL ;
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/vexcl/Jamfile.v2:        <include>$(CUDA_INCLUDE)
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/vexcl/Jamfile.v2:exe lorenz_ensemble : lorenz_ensemble.cpp opencl ;
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/vexcl/lorenz_ensemble.cpp:    // setup the opencl context
thirdParty/bgen/3rd_party/boost_1_55_0/libs/numeric/odeint/examples/vexcl/lorenz_ensemble.cpp:    vex::Context ctx( vex::Filter::Type(CL_DEVICE_TYPE_GPU) );
thirdParty/bgen/3rd_party/boost_1_55_0/tools/inspect/ascii_check.cpp:    static const string gPunct ( "$_{}[]#()<>%:;.?*+-/ˆ&|~!=,\\\"'@^`" );
thirdParty/bgen/3rd_party/boost_1_55_0/tools/inspect/ascii_check.cpp:         return gPunct.find ( c ) == string::npos;
thirdParty/bgen/3rd_party/boost_1_55_0/status/explicit-failures-markup.xml:            <toolset name="cuda-2.2"/>
thirdParty/bgen/3rd_party/boost_1_55_0/boost/math/special_functions/lanczos.hpp:#if !defined(_CRAYC) && !defined(__CUDACC__) && (!defined(__GNUC__) || (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ > 3)))
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/compiler/gcc.hpp:#if !defined(__CUDACC__)
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/compiler/gcc.hpp:// doesn't actually support __int128 as of CUDA_VERSION=5000
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/compiler/gcc.hpp:#if defined(__SIZEOF_INT128__) && !defined(__CUDACC__)
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/compiler/nvcc.hpp://  NVIDIA CUDA C++ compiler setup
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/compiler/nvcc.hpp:#  define BOOST_COMPILER "NVIDIA CUDA C++ Compiler"
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/compiler/nvcc.hpp:// NVIDIA Specific support
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/compiler/nvcc.hpp:// BOOST_GPU_ENABLED : Flag a function or a method as being enabled on the host and device
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/compiler/nvcc.hpp:#define BOOST_GPU_ENABLED __host__ __device__
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/select_compiler_config.hpp:#if defined __CUDACC__
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/select_compiler_config.hpp://  NVIDIA CUDA C++ compiler for GPU
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/suffix.hpp:// Set some default values GPU support
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/suffix.hpp:#  ifndef BOOST_GPU_ENABLED
thirdParty/bgen/3rd_party/boost_1_55_0/boost/config/suffix.hpp:#  define BOOST_GPU_ENABLED
thirdParty/bgen/3rd_party/boost_1_55_0/boost/asio/basic_signal_set.hpp: * POSIX allows signals to be blocked using functions such as @c sigprocmask()
thirdParty/bgen/3rd_party/boost_1_55_0/boost/numeric/odeint/util/unit_helper.hpp:#ifndef __CUDACC__
thirdParty/bgen/3rd_party/boost_1_55_0/boost/numeric/odeint/util/unit_helper.hpp:#ifndef __CUDACC__
thirdParty/bgen/3rd_party/boost_1_55_0/boost/numeric/odeint/util/unit_helper.hpp:#ifndef __CUDACC__
thirdParty/bgen/3rd_party/boost_1_55_0/boost/numeric/odeint/util/unit_helper.hpp:#ifndef __CUDACC__
thirdParty/bgen/3rd_party/boost_1_55_0/boost/numeric/odeint/util/unit_helper.hpp:#ifndef __CUDACC__
thirdParty/bgen/3rd_party/boost_1_55_0/boost/numeric/odeint/algebra/detail/macros.hpp:#ifndef __CUDACC__
thirdParty/bgen/3rd_party/boost_1_55_0/boost/numeric/odeint/algebra/detail/macros.hpp:#endif // __CUDACC__
thirdParty/bgen/3rd_party/boost_1_55_0/boost/numeric/odeint.hpp:#ifndef __CUDACC__
thirdParty/bgen/3rd_party/boost_1_55_0/boost/preprocessor/config/config.hpp:#    if defined __GCCXML__ || defined __CUDACC__ || defined __PATHSCALE__ || defined __clang__ || defined __DMC__ || defined __CODEGEARC__ || defined __BORLANDC__ || defined __MWERKS__ || defined __SUNPRO_CC || defined __HP_aCC && !defined __EDG__ || defined __MRC__ || defined __SC__ || defined __IBMCPP__ || defined __PGI
thirdParty/bgen/3rd_party/boost_1_55_0/boost/preprocessor/config/config.hpp:#    if defined _MSC_VER && _MSC_VER >= 1400 && !(defined __EDG__ || defined __GCCXML__ || defined __CUDACC__ || defined __PATHSCALE__ || defined __clang__ || defined __DMC__ || defined __CODEGEARC__ || defined __BORLANDC__ || defined __MWERKS__ || defined __SUNPRO_CC || defined __HP_aCC || defined __MRC__ || defined __SC__ || defined __IBMCPP__ || defined __PGI)
thirdParty/bgen/3rd_party/boost_1_55_0/boost/type_traits.hpp:#if !defined(__BORLANDC__) && !defined(__CUDACC__)
thirdParty/bgen/3rd_party/boost_1_55_0/boost/concept/detail/has_constraints.hpp:#if BOOST_WORKAROUND(__SUNPRO_CC, <= 0x580) || defined(__CUDACC__)

```
