# https://github.com/fury-gl/fury

```console
paper.bib:  title={VisPy: harnessing the GPU for fast, high-level visualization},
paper.bib:@article{harris2009cuda,
paper.bib:  title={CUDA Fluid Simulation in NVIDIA PhysX},
docs/source/introduction.rst:FURY is a community-driven, open-source, and high-performance scientific visualization library that harnesses the graphics processing unit (GPU) for improved speed, precise interactivity, and visual clarity.
docs/source/release_notes/releasev0.7.1.rst:* :ghpull:`438`: Fast selection of multiple objects in 3D using GPU acceleration
docs/source/release_notes/releasev0.7.1.rst:* :ghissue:`438`: Fast selection of multiple objects in 3D using GPU acceleration
docs/source/posts/2021/2021-07-12-gsoc-devmessias-6.rst:with cuda installed. See the list of opened
docs/source/posts/2021/2021-06-21-week-3-antriksh.rst:* `Study #422 PR to understand contours around the drawn markers <https://github.com/fury-gl/fury/pull/422>`_ : In my previous week's tasks I created a PR to add support for borders in Panel2D. The borders were individually customizable just like in CSS which meant 4 Rectangle2D objects were needed to represent border in each direction. This is not ideal for a scenario where a lot of Panel2D are present in the scene as it can be performance taxing. A possible solution for this was to actually look how this was implemented in the #422. This PR allowed drawing millions of markers in one call that too from the GPU. Interestingly, each marker had a contour surrounding it which is exactly what we needed for Panel2D. This is something that can be considered in the future for border implementation in other complex UI elements.
docs/source/posts/2021/2021-08-23-gsoc-devmessias-final-report.rst:|                 | using cugraph/cuda          |                             |
docs/source/posts/2021/2021-08-23-gsoc-devmessias-final-report.rst:|                 | without any expensive GPU;  | /weekly-check-in-11-13/>`__ |
docs/source/posts/2021/2021-06-12-gsoc-devmessias-2.rst:available. For example, with the GPUs prices increasing, itâ€™s necessary
docs/source/posts/2021/2021-06-12-gsoc-devmessias-2.rst:to share a machine with a GPU with different users in different
docs/source/posts/2021/2021-06-12-gsoc-devmessias-2.rst:  caused by the GPU-CPU copy from the opengl context. However, I
docs/source/posts/2021/2021-06-12-gsoc-devmessias-2.rst:takes a large amount of time, more than GPU-CPU copy. The explanation
docs/source/posts/2020/2020-08-24-final-work-lenix.rst:The spherical harmonics algorithm is used to generate spherical surfaces using biases and coefficients computed. The general approach to achieve this is computationally expensive. The idea proposed was to leverage the GPU hardware using shaders to provide a faster more efficient alternative to the current implementations. The second month of the coding period was devoted to the same task but unfortunately, the observed performance was quite unsatisfactory than the expected performance. Moreover, the output shape of the geometry was distorted. It was then decided to continue the work after the GSoC period and prioritize the task at hand.
docs/source/posts/2024/2024-07-27-week-7-robin.rst:I majorly took this week off due to my semester final examinations :) They were fun. Major topics were x86, ARM and 8051. I had not written a lot of assembly apart from school work. I took the week to experiment with some assembly. The course was more into hardware architecture than programming. I've now enough knowledge to read a given piece of ASM code with a wiki to look up mnemonics (and Gemini/Claude to help). I'm not fast in writing ASM (yet), one day I'll find a project to dive into, or maybe some reverse engineering and CTFs. GPU instruction sets are also something interesting.
docs/source/posts/2023/2023-07-31-week-9-joaodellagli.rst:old one, being reported in `GPU Gems's chapter 12 <https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-12-omnidirectional-shadow-mapping>`_.
docs/source/posts/2023/2023-08-21-joaodellagli-final-report.rst:    `GPU Gems 12.3.3 section <https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-12-omnidirectional-shadow-mapping>`_:
docs/source/posts/2023/2023-01-29-final-report-mohamed.rst:    Animating FURY actors is not a problem and can be done easily using the FURY animation module. The problem appears when trying to animate a massive amount of actors, thousands or even hundreds of thousands of actors, it's impossible to do that using the animation module. Instead, primitives of the same actor can be animated by changing their vertices and then sending the new vertices buffer to the GPU. This also needs some discussion to find the cleanest way to implement it.
docs/source/posts/2023/2023-01-29-final-report-mohamed.rst:    Using the power of the GPU to help speed up the animations since some interpolators are relatively slow, such as the spline interpolator. Besides, morphing and skeletal animation would be tremendously optimized if they were computed on the GPU side!
docs/source/posts/2023/2023-01-29-final-report-mohamed.rst:     - Redesigning the API,\ :raw-html:`<br>` Implementing cubic Bezier Interpolator,\ :raw-html:`<br>` and making progress on the GPU side!
docs/source/posts/2023/2023-01-29-final-report-mohamed.rst:     - `FURY <https://fury.gl/latest/posts/2022/2022-07-04-week-3-mohamed.html>`__ - `Python <https://blogs.python-gsoc.org/en/m-agours-blog/week-3-redesigning-the-api-implementing-cubic-bezier-interpolator-and-making-progress-on-the-gpu-side/>`__
docs/source/posts/2022/2022-07-04-week-3-mohamed.rst:Week 3: Redesigning the API, Implementing cubic Bezier Interpolator, and making progress on the GPU side!
docs/source/posts/2022/2022-07-04-week-3-mohamed.rst:- Also Implemented linear and cubic Bezier in GLSL interpolations to be computed by the GPU by sending two keyframes as uniforms and the current animation time.
docs/source/posts/2022/2022-06-28-week-2-mohamed.rst:- Managed to do the transformation on the GPU side using GLSL using matrices. And did some digging about how and when we interpolate the camera and also how to do this on the GPU side.
docs/source/posts/2022/2022-08-09-week-8-mohamed.rst:- As for how keyframes are sent to the GPU, the method being used is to send the needed keyframes for each draw. This is heavy because we only roll out the interpolation part, which with linear or step interpolation won't make any difference! Instead, I tried setting all the keyframes at once as a GLSL variable using string manipulation before animation starts. This also was slow to initialize, and the shader was getting bigger and slower to bind and unbind. To solve this problem, I made a uniform that holds all the keyframes of the animation and sent data as vectors, which was faster than string manipulation, also it was faster to render since data are now stored directly in memory, and the shader program was a lot more compact. But this method had an issue; uniforms do not keep data stored as expected! If two or more actors have the same uniform name in their shader program and only one of them was set, the other actor will get this value as well. A way around this is to change the names of the uniforms so that they maintain their data.
docs/source/posts/2022/2022-05-23-first-post-mohamed.rst:So, no Numpy, no PyGLM, fixed pipelines, no custom shaders, and each vertex had to be sent individually to the GPU.
fury/actor.py:    Streamtubes can be heavy on GPU when loading many streamlines and
fury/actor.py:    therefore, you may experience slow rendering time depending on system GPU.
paper.md:Free Unified Rendering in pYthon (FURY), is a community-driven, open-source, and high-performance scientific visualization library that harnesses the graphics processing unit (GPU) for improved speed, precise interactivity, and visual clarity. FURY provides an integrated API in Python that allows UI elements and 3D graphics to be programmed together. FURY is designed to be fully interoperable with most projects of the Pythonic ecosystem that use NumPy [@harris2020array] for processing numerical arrays. In addition, FURY uses core parts of VTK [@schroeder1996visualization] and enhances them using customized shaders. FURY provides access to the latest technologies such as raytracing, signed distance functionality, physically based rendering, and collision detection for direct use in research. More importantly, FURY enables students and researchers to script their own 3D animations in Python and simulate dynamic environments.
paper.md:**Physics Engine**: This engine allows us to either build collision mechanisms as used in molecular dynamics or integrate well-established engines such as Bullet [@coumans2013bullet] and NVIDIA PhysX [@harris2009cuda].

```
